name: Release — Test, Build, Push, Deploy

# Release — Test, Build, Push, Deploy
# CI/CD pipeline triggered after infra release or manually.
# - Establishes release version from tag or workflow
# - Detects app changes between releases
# - Runs PHP tests, static analysis, and security scans
# - Builds and pushes Docker image to ECR (if changed)
# - Retags latest image if unchanged
# - Deploys to EC2 via SCP/SSH, updating files and running compose
# - Manages SSH access for runner

on:
  workflow_run:
    workflows: ["Release — Terraform"]
    types: [completed]
  workflow_dispatch:
    inputs:
      version_tag:
        description: 'Tag to deploy (e.g., v1.2.3)'
        required: false

concurrency:
  group: release-${{ github.run_id }}
  cancel-in-progress: false

permissions:
  contents: read
  id-token: write
  security-events: write

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  ECR_REPO: ksymfony

jobs:
  establish-version:
    runs-on: ubuntu-latest
    outputs:
      VERSION: ${{ steps.setver.outputs.VERSION }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - id: setver
        run: |
          set -euo pipefail
          if [ -n "${{ github.event.inputs.version_tag || '' }}" ]; then
            ver="${{ github.event.inputs.version_tag }}"
          elif [ "${{ github.event.workflow_run.conclusion || '' }}" = "success" ]; then
            sha="${{ github.event.workflow_run.head_sha }}"
            git fetch --tags --force
            ver=$(git tag --points-at "$sha" | grep -E '^v[0-9]' | head -n1 || true)
          else
            ver="${GITHUB_REF_NAME:-}"
          fi
          if [ -z "$ver" ]; then
            echo "Could not determine release tag." >&2
            exit 1
          fi
          echo "VERSION=$ver" >> "$GITHUB_OUTPUT"

  detect-changes:
    needs: establish-version
    runs-on: ubuntu-latest
    outputs:
      app_changed: ${{ steps.decide.outputs.app }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - id: decide
        run: |
          set -euo pipefail
          VERSION="${{ needs.establish-version.outputs.VERSION }}"
          if [ -n "${{ github.event.inputs.version_tag || '' }}" ]; then
            echo "app=false" >> "$GITHUB_OUTPUT"  # user asked a specific tag; don't rebuild
            exit 0
          else
            git fetch --tags --force
            prev=$(git tag --sort=-creatordate -l 'v*' | grep -v "^$VERSION$" | head -n1 || true)
            if [ -z "$prev" ]; then
              echo "app=true" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            if git diff --name-only "$prev" "$VERSION" -- \
                 Dockerfile docker/ src/ public/ config/ composer.json composer.lock \
                 | grep . >/dev/null; then
              echo "app=true" >> "$GITHUB_OUTPUT"
            else
              echo "app=false" >> "$GITHUB_OUTPUT"
            fi
          fi

  # ---------- CI: tests & static analysis ----------
  php-ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: shivammathur/setup-php@v2
        with:
          php-version: '8.3'
          coverage: none
          extensions: intl
      - name: Cache Composer
        uses: actions/cache@v4
        with:
          path: ~/.composer/cache
          key: composer-${{ hashFiles('**/composer.lock') }}
          restore-keys: composer-
      - name: Install deps
        run: composer install --no-interaction --prefer-dist --no-progress
      - name: PHPUnit
        run: vendor/bin/phpunit --testdox
      - name: Composer audit
        run: composer audit --locked --no-interaction
      - name: PHPStan
        run: vendor/bin/phpstan analyse --memory-limit=1G
      - name: PHP-CS-Fixer (check)
        run: vendor/bin/php-cs-fixer fix --dry-run --diff

  # ---------- CI: Trivy (repo filesystem + config) ----------
  trivy-fs:
    runs-on: ubuntu-latest
    needs: php-ci
    steps:
      - uses: actions/checkout@v4

      - name: Trivy FS scan
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: fs
          ignore-unfixed: true
          severity: HIGH,CRITICAL
          format: sarif
          output: trivy-fs.sarif

      - name: Trivy FS scan (Table)
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: fs
          ignore-unfixed: true
          severity: HIGH,CRITICAL
          format: table
          output: trivy-fs.txt

      - name: Publish FS table to job summary
        if: always()
        run: |
          if [ -s trivy-fs.txt ]; then
            {
              echo "### Trivy IaC — FS HIGH,CRITICAL"
              echo '```'
              cat trivy-fs.txt
              echo '```'
            } >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Trivy config scan (Dockerfile/compose/IaC)
        uses: aquasecurity/trivy-action@0.33.1
        continue-on-error: true
        with:
          scan-type: config
          ignore-unfixed: true
          severity: HIGH,CRITICAL
          format: sarif
          output: trivy-config.sarif
      
      - name: Trivy config scan (Table)
        uses: aquasecurity/trivy-action@0.33.1
        continue-on-error: true
        with:
          scan-type: config
          ignore-unfixed: true
          severity: HIGH,CRITICAL
          format: table
          output: trivy-config.txt

      - name: Publish config table to job summary
        if: always()
        run: |
          if [ -s trivy-config.txt ]; then
            {
              echo "### Trivy IaC — Config CRITICAL"
              echo '```'
              cat trivy-config.txt
              echo '```'
            } >> "$GITHUB_STEP_SUMMARY"
          fi
      - name: Upload SARIF (fs)
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: trivy-fs.sarif
          category: trivy-fs 

      - name: Upload SARIF (config)
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: trivy-config.sarif
          category: trivy-config

  # ---------- CD: build/scan/push (or retag) ----------
  build-and-push:
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    needs: [establish-version, detect-changes, php-ci, trivy-fs]
    runs-on: ubuntu-latest
    env:
      VERSION: ${{ needs.establish-version.outputs.VERSION }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ env.VERSION }}

      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.APP_AWS_ROLE_ARN }}
          mask-aws-account-id: true

      - name: Ensure ECR repo exists
        run: |
          set -euo pipefail
          if ! aws ecr describe-repositories --repository-names "${ECR_REPO}" >/dev/null 2>&1; then
            aws ecr create-repository --repository-name "${ECR_REPO}" \
              --image-scanning-configuration scanOnPush=true \
              --image-tag-mutability MUTABLE
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      # Check if this exact version tag already exists in ECR
      - name: Check if ECR has this version
        id: has_ver
        run: |
          set -euo pipefail
          if aws ecr describe-images \
               --repository-name "${ECR_REPO}" \
               --image-ids imageTag="${{ env.VERSION }}" >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi
      
      - name: Check if ECR :latest exists
        id: has_latest
        run: |
          set -euo pipefail
          if aws ecr describe-images --repository-name "${ECR_REPO}" \
               --image-ids imageTag=latest >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      # Create VERSION from :latest when unchanged and VERSION missing
      - name: Create :${{ env.VERSION }} from :latest (unchanged)
        if: needs.detect-changes.outputs.app_changed != 'true' && steps.has_ver.outputs.exists != 'true' && steps.has_latest.outputs.exists == 'true'
        run: |
          set -euo pipefail
          RESP=$(aws ecr batch-get-image \
            --repository-name "${ECR_REPO}" \
            --image-ids imageTag=latest \
            --accepted-media-types \
              application/vnd.docker.distribution.manifest.v2+json \
              application/vnd.oci.image.manifest.v1+json \
              application/vnd.docker.distribution.manifest.list.v2+json \
              application/vnd.oci.image.index.v1+json \
            --output json)
          echo "$RESP" | jq -r '.images[0].imageManifest' > manifest.json
          MEDIA=$(echo "$RESP" | jq -r '.images[0].imageManifestMediaType // empty')
          if [ -s manifest.json ]; then
            if [ -n "$MEDIA" ]; then
              aws ecr put-image \
                --repository-name "${ECR_REPO}" \
                --image-tag "${{ env.VERSION }}" \
                --image-manifest file://manifest.json \
                --image-manifest-media-type "$MEDIA"
            else
              aws ecr put-image \
                --repository-name "${ECR_REPO}" \
                --image-tag "${{ env.VERSION }}" \
                --image-manifest file://manifest.json
            fi
          else
            echo "Empty manifest from :latest"; exit 1
          fi

      # Fallback build when neither VERSION nor :latest exist (unchanged path)
      - name: Fallback build & push (unchanged, no :latest)
        if: needs.detect-changes.outputs.app_changed != 'true' && steps.has_ver.outputs.exists != 'true' && steps.has_latest.outputs.exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          platforms: linux/amd64
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPO }}:${{ env.VERSION }}
          build-args: |
            APP_VERSION=${{ env.VERSION }}
          cache-from: type=gha,scope=${{ env.ECR_REPO }}
          cache-to: type=gha,mode=max,scope=${{ env.ECR_REPO }}
        
      # ---- Build (local) & scan image BEFORE pushing (when changed) ----
      - name: Build image (load locally for scan)
        if: needs.detect-changes.outputs.app_changed == 'true' && steps.has_ver.outputs.exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          load: true
          platforms: linux/amd64
          tags: app:ci-${{ github.sha }}
          build-args: |
            APP_VERSION=${{ env.VERSION }}
          cache-from: type=gha,scope=${{ env.ECR_REPO }}
          cache-to: type=gha,mode=max,scope=${{ env.ECR_REPO }}
          
      - name: Trivy scan — image (local)
        if: needs.detect-changes.outputs.app_changed != 'true' && steps.has_latest.outputs.exists == 'true'
        uses: aquasecurity/trivy-action@0.33.1
        continue-on-error: true
        with:
          image-ref: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPO }}:latest
          vuln-type: 'os,library'
          ignore-unfixed: true
          severity: 'HIGH,CRITICAL'
          format: sarif
          output: trivy-image.sarif

      - name: Upload SARIF (image)
        if: needs.detect-changes.outputs.app_changed != 'true' && steps.has_latest.outputs.exists == 'true' && always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-image.sarif
          category: trivy-image

      # ---- Push only the version tag on changed builds (never push :latest) ----
      - name: Build & push image (changed)
        if: needs.detect-changes.outputs.app_changed == 'true' && steps.has_ver.outputs.exists != 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          platforms: linux/amd64
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPO }}:${{ env.VERSION }}

          build-args: |
            APP_VERSION=${{ env.VERSION }}
          cache-from: type=gha,scope=${{ env.ECR_REPO }}
          cache-to: type=gha,mode=max,scope=${{ env.ECR_REPO }}

      # Make :latest point to the selected VERSION (idempotent, no rebuild)
      - name: Ensure :latest equals :${{ env.VERSION }} (no rebuild)
        run: |
          set -euo pipefail

          # --- Fetch manifest & digest for the target version ---
          RESP=$(aws ecr batch-get-image \
            --repository-name "${ECR_REPO}" \
            --image-ids imageTag="${{ env.VERSION }}" \
            --accepted-media-types \
              application/vnd.docker.distribution.manifest.v2+json \
              application/vnd.oci.image.manifest.v1+json \
              application/vnd.docker.distribution.manifest.list.v2+json \
              application/vnd.oci.image.index.v1+json \
            --output json)
          
          if [ -z "$RESP" ] || [ "$(echo "$RESP" | jq '.images | length')" -eq 0 ]; then
            echo "::error::ECR does not have ${ECR_REPO}:${{ env.VERSION }}; cannot set :latest"
            exit 1
          fi
          
          echo "$RESP" | jq -r '.images[0].imageManifest' > manifest.json
          MEDIA=$(echo "$RESP" | jq -r '.images[0].imageManifestMediaType // empty')
          VER_DIGEST=$(echo "$RESP" | jq -r '.images[0].imageId.imageDigest // empty')
          
          # --- If :latest exists, skip (immutable tags) ---
          LATEST_DESC=$(aws ecr describe-images \
            --repository-name "${ECR_REPO}" \
            --image-ids imageTag=latest \
            --output json 2>/dev/null || true)
          
          if [ -n "$LATEST_DESC" ] && [ "$(echo "$LATEST_DESC" | jq '.imageDetails | length')" -gt 0 ]; then
            LAT_DIGEST=$(echo "$LATEST_DESC" | jq -r '.imageDetails[0].imageDigest // empty')
            if [ -n "$LAT_DIGEST" ] && [ "$LAT_DIGEST" = "$VER_DIGEST" ]; then
              echo "':latest' already points to ${{ env.VERSION }} ($VER_DIGEST); nothing to do."
            else
              echo "':latest' already exists (digest: $LAT_DIGEST). Repo likely immutable; skipping retag."
            fi
            exit 0
          fi
          
          # --- Try to create :latest; if a race occurs, verify and ignore the error ---
          set +e
          if [ -n "$MEDIA" ]; then
            PUT_OUT=$(aws ecr put-image \
              --repository-name "${ECR_REPO}" \
              --image-tag latest \
              --image-manifest file://manifest.json \
              --image-manifest-media-type "$MEDIA" 2>&1)
          else
            PUT_OUT=$(aws ecr put-image \
              --repository-name "${ECR_REPO}" \
              --image-tag latest \
              --image-manifest file://manifest.json 2>&1)
          fi
          PUT_RC=$?
          set -e
          
          if [ $PUT_RC -eq 0 ]; then
            echo "Tagged :latest -> ${{ env.VERSION }} ($VER_DIGEST)."
            exit 0
          fi
          
          # If we got ImageAlreadyExistsException (race/immutable), treat as success if latest now exists
          if echo "$PUT_OUT" | grep -q 'ImageAlreadyExistsException'; then
            echo "put-image reported ImageAlreadyExistsException; checking current :latest…"
            LATEST_DESC=$(aws ecr describe-images \
              --repository-name "${ECR_REPO}" \
              --image-ids imageTag=latest \
              --output json 2>/dev/null || true)
            LAT_DIGEST=$(echo "$LATEST_DESC" | jq -r '.imageDetails[0].imageDigest // empty')
            if [ -n "$LAT_DIGEST" ]; then
              if [ "$LAT_DIGEST" = "$VER_DIGEST" ]; then
                echo "Confirmed: ':latest' now points to the same digest ($LAT_DIGEST). Treating as success."
                exit 0
              else
                echo "':latest' exists with a different digest ($LAT_DIGEST). Repo enforces immutability; skipping update by design."
                exit 0
              fi
            fi
          fi
          
          echo "::warning::put-image failed with unexpected error:"
          echo "$PUT_OUT"
          # Don’t fail the workflow on immutable/race conditions; fail only on real errors you care about.
          exit 0
          

      - name: Trivy scan — final image (registry)
        if: needs.detect-changes.outputs.app_changed != 'true'
        uses: aquasecurity/trivy-action@0.33.1
        with:
          image-ref: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPO }}:${{ env.VERSION }}
          vuln-type: 'os,library'
          ignore-unfixed: true
          format: sarif
          severity: 'HIGH,CRITICAL'
          exit-code: '1'
          output: trivy-image-final.sarif
      
      - name: Upload SARIF (final image)
        if: needs.detect-changes.outputs.app_changed != 'true' && always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy-image-final.sarif
          category: trivy-image-final


  # ---------- CD: deploy ----------
  deploy:
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    needs: [build-and-push, establish-version]
    runs-on: ubuntu-latest
    environment: prod
    env:
      VERSION: ${{ needs.establish-version.outputs.VERSION }}
      AWS_REGION: ${{ vars.AWS_REGION }}
      ECR_REPO: ksymfony
    steps:
      - name: Configure AWS (OIDC)
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.APP_AWS_ROLE_ARN }}
          mask-aws-account-id: true

      - name: Discover instance (Project=ksymfony)
        id: find
        run: |
          set -euo pipefail
          HOST=$(aws ec2 describe-instances \
            --filters "Name=tag:Project,Values=ksymfony" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].PublicDnsName" --output text)
          if [ -z "$HOST" ] || [ "$HOST" = "None" ]; then
            HOST=$(aws ec2 describe-instances \
              --filters "Name=tag:Project,Values=ksymfony" "Name=instance-state-name,Values=running" \
              --query "Reservations[].Instances[].PublicIpAddress" --output text)
          fi
          if [ -z "$HOST" ] || [ "$HOST" = "None" ]; then
            echo "No running instance found"
            exit 1
          fi
          echo "host=$HOST" >> "$GITHUB_OUTPUT"

      - name: Discover SSH CI Security Group ID
        id: sg
        run: |
          set -euo pipefail
          SG_ID=$(aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=ksymfony-ssh-ci" "Name=tag:Project,Values=ksymfony" \
            --query "SecurityGroups[0].GroupId" --output text)
          if [ -z "$SG_ID" ] || [ "$SG_ID" = "None" ]; then
            echo "Could not find 'ksymfony-ssh-ci' security group" >&2
            exit 1
          fi
          echo "id=$SG_ID" >> "$GITHUB_OUTPUT"

      - name: Authorize THIS runner IP for SSH (22)
        id: open_ssh
        run: |
          set -euo pipefail
          RUNNER_IP=$(curl -s https://api.ipify.org)
          echo "runner_ip=$RUNNER_IP" >> "$GITHUB_OUTPUT"
          aws ec2 authorize-security-group-ingress \
            --group-id "${{ steps.sg.outputs.id }}" \
            --ip-permissions "IpProtocol=tcp,FromPort=22,ToPort=22,IpRanges=[{CidrIp=${RUNNER_IP}/32,Description=GitHubActions}]"

      - name: Get ECR login password
        id: ecrpass
        run: echo "pwd=$(aws ecr get-login-password --region $AWS_REGION)" >> "$GITHUB_OUTPUT"

      - uses: actions/checkout@v4

      - name: Preflight — verify files exist
        run: |
          set -euo pipefail
          echo "Top-level files:" && ls -la
          echo "docker/nginx:" && ls -la docker/nginx || true
          echo "deploy:" && ls -la deploy || true
          paths=('public/**' 'docker/nginx/default.conf' 'deploy/docker-compose.ec2.yml')
          for p in "${paths[@]}"; do
            if ! compgen -G "$p" >/dev/null; then
              echo "::error::No files matched '$p' in $GITHUB_WORKSPACE"
              exit 1
            fi
          done

      - name: Stage files for deploy
        run: |
          set -euo pipefail
          rm -rf _deploy && mkdir -p _deploy/docker/nginx _deploy/deploy
          cp -a public _deploy/public
          cp docker/nginx/default.conf _deploy/docker/nginx/default.conf
          cp deploy/docker-compose.ec2.yml _deploy/deploy/docker-compose.ec2.yml
          find _deploy -maxdepth 3 -type f -printf "%P\n"

      - name: Copy deployment files to EC2
        uses: appleboy/scp-action@v1
        with:
          host: ${{ steps.find.outputs.host }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          fingerprint: ${{ secrets.EC2_HOST_FINGERPRINT }}
          source: _deploy
          target: /opt/app
          debug: true

      - name: Deploy (compose pull/up with version tag)
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ steps.find.outputs.host }}
          username: ${{ secrets.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          fingerprint: ${{ secrets.EC2_HOST_FINGERPRINT }}
          envs: AWS_REGION,ECR_REPO,VERSION
          script: |
            set -euo pipefail
            cd /opt/app

            if [ -d "_deploy" ]; then
              mkdir -p docker/nginx deploy
              shopt -s dotglob
              cp -a _deploy/public ./ || true
              cp -a _deploy/docker/nginx/default.conf docker/nginx/default.conf || true
              cp -a _deploy/deploy/docker-compose.ec2.yml deploy/docker-compose.ec2.yml || true
              shopt -u dotglob
              rm -rf _deploy
            fi

            ACCOUNT_ID="$(aws sts get-caller-identity --query Account --output text --region "$AWS_REGION")"
            REG="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"
            ECR_URL="$REG/${ECR_REPO}"
            APP="$ECR_URL:${VERSION}"

            echo "${{ steps.ecrpass.outputs.pwd }}" | docker login --username AWS --password-stdin "$REG"

            DIGEST=$(aws ecr batch-get-image \
              --repository-name "${ECR_REPO}" \
              --image-ids imageTag="${VERSION}" \
              --query 'images[0].imageId.imageDigest' --output text)
            echo "Deploying ${APP} @ ${DIGEST}"

            printf "APP_IMAGE=%s\nAPP_VERSION=%s\n" "$APP" "$VERSION" > .env

            docker compose --env-file .env -f deploy/docker-compose.ec2.yml pull
            docker compose --env-file .env -f deploy/docker-compose.ec2.yml up -d

            docker image prune -f || true

      - name: Revoke THIS runner IP for SSH (22)
        if: always()
        run: |
          set -euo pipefail
          RUNNER_IP="${{ steps.open_ssh.outputs.runner_ip }}"
          aws ec2 revoke-security-group-ingress \
            --group-id "${{ steps.sg.outputs.id }}" \
            --protocol tcp --port 22 \
            --cidr "${RUNNER_IP}/32" || true
